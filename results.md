# Dijkstra's algorithm
Dijkstra’s Algorithm is the main search algorithm our optimizing the climb project uses. It works by following the given algorithm on the CS225 website. This means that we use a min priority heap to hold and shuffle through the best possible paths for the hiker. The great part about this algorithm is its run time. Being O(E+log(V)),  since we are using a heap. Since we store previous attempts, it makes it easy to scale up. While it wasn’t planned, being able to bring in larger height maps greatly improves the visualization of our program. The test cases for this program rely on two very specific images that we know their output too. At first, we printed out the edges and followed the print output to the solution we desired. Once we got that going, we moved on to rendering out output to see more varied solutions. This allowed us to see the correct output. Final testing is based on verify pixels by comparing them to a master image similar to the way past MP’s did it. Below is the output after rendering Dijkstra’s algorithm. This image will be compared to a master image pixel by pixel to ensure it is correct. 

# A* algorithm
As this algorithm is very similar to Dijkstra’s, the procedure for it was much faster. With the heuristic, the run time should be slowest with o(NlogN). Our goal with A* was not the perfect solution, but the fastest. We know that A* is most efficient at finding good solutions, not perfect ones. With this in mind, we set out to make our heuristic function based on 4 directions. We used the basic Manthan case to calculate this heuristic and add it to our search. This allowed us to traverse the height map much quicker. To test this, we used the already existing test cases for Dijkstra since they both do the same task. 

# BFS
Unfortunately, due to us not knowing how to implement this into one of our functions, this was sadly forgotten about until the very end. We know that BFS would have been much slower at solving the optimizing the climb since it has high spatial complexity. The time complexity o(N)N has the potential to drag on far longer than the other shortest path algorithms. The tests for this would have also been reliant on seeing the visual output of the algorithm on the working render function from the other algorithms.

# Leading question: How and Why Find the Path of Least Resistance Up Any Terrain?
Why the path of least resistance? Why optimize the climb? As the reliance on electronic maps has increased for all forms of transportation, other “niche” activities have been left out. Google maps can tell you about walking, biking, and public, vehicle and even give you flights if you need them. One of those areas that have been left out is the hiking scene. Planning a hike that is one of the most important processes before you go boots on the ground. As a user, you must likely want paths that are either difficult, energy-conserving, or safe. This is where our optimizing the climb project comes in. Our project will give you the most energy-efficient path on the luminance of the terrain. This means that the algorithm will avoid steep climbs and guide the user to the fastest energy-efficient path. If the user doesn’t want the most optimal path, they instead rely on a faster algorithm that will return a map much faster at the cost of not being the best path.

The way our algorithm works is three-fold. The first part is the image. A 600x600 greyscale image is inserted into the program. It then gets its luminance values put into a map. From here, the map edges and weights. The weights will be the absolute value of the difference between nodes. This allows use them as pathfinders to where the path of least resistance would be.  Then from here, one of the many shortest paths algorithms are used. After this, a path is drawn on the png like in MP_mazes and outputed back out. 

As the project went on, we quickly discovered that timing was an issue for us. With one of our members getting covid and cascading it to the rest. Along with the one break week is full of exams for all of us. With this in mind, we quickly realized that the full scope of the project could not be realized. We decided to abandon any complex tasks that would take away time from the main algorithms. This means that the OpenGL and Minecraft applications, unfortunately, had to be scrapped. We discovered that implementing classes on your own was hard. Knowing what a class will need in the future was difficult for us to grasp. Luckily, asking and talking through our ideas with TAs during office hours helped us get a start on writing the code. We also noticed that there is always more than one way to implement a program. This was troubling at the beginning because some of us were debating the use of maps over vectors but ultimately we were forced to use weighted maps since it would greatly simplify the shortest path algorithms. 

In terms of self-discovery through coding, many of us felt that we learned more in the span of a week than in the entire class. Knowing how to take parts of our MP’s and remix them into fitting often didn’t work, We had to research stack overflow and look for ideas that we could make our own. We felt that we grew as programmers. We also discovered that good old print statements are still amazing for debugging. This was the main way we were able to see what exactly was going on with our code. In the end, when Dijkstra worked we were ecstatic that it worked. We feel that this was the breakthrough. We wish we could have taken it further. 

Unfortunately, due to the lack of knowledge from the team and time we didn’t manage to hit all our goals for this project. Having Dijkstra’s work for us was our proudest movement. In terms of team activities what worked was the style of weekly logs and check-ins. Also, working during office hours was amazing since it let us end debates within the team about what process for implementation was better. Saving us time and helping us get moving.  However, towards the end of the project, we found ourselves concerned about both the final project and the new MP. Also, some of our members struggled with writing certain code since they had to drop an MP(mazes) due to covid. This left us with gaps in what people knew. Towards the end, we had help from many other outside sources to help us debug the code. What we could have done differently as a team is starting the brainstorming process faster and avoiding having to redo the project proposal since that set us back. We also had to meet up more often at the start so that we could have separated earlier to work semi-independently. 